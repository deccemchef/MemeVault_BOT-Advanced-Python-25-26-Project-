# SOLID

## S — Single Responsibility Principle  
(Принцип единственной ответственности)

У каждого класса должна быть **только одна причина для изменения** –  
каждый класс делает **что-то одно**, а не всё подряд.

**Плохо:**

Класс UserManager и читает пользователей, и пишет их, и валидирует пароль, и отправляет email

**Хорошо:**

Разбить:
```text
- UserRepository — работа с базой
- UserValidator — проверка данных
- EmailService — отправка писем
- UserService — бизнес-логика
```
---

## O — Open/Closed Principle  
(Принцип открытости/закрытости)

Код должен быть **открыт для расширения**, но **закрыт для изменения**.

Когда нужны новые функции, мы:
- **добавляем новые классы/методы**,  
- **а не меняем** уже работающий код, чтобы ничего не сломать.

**Плохо:**

В PaymentProcessor вписать if paypal, if yoomoney, if sbp, if crypto

**Хорошо:**

Создать интерфейс PaymentMethod и реализовать его:
```text
PayPalPayment
CryptoPayment
YooMoneyPayment
```
PaymentProcessor просто вызывает .pay(), не зная детали

---

## L — Liskov Substitution Principle  
(Принцип подстановки Барбары Лисков)

Дочерний класс должен **полностью заменять родительский**, не ломая логику.

Если мы подставляем наследника вместо родителя —  
**ничего не должно ломаться** в поведении программы.

**Плохо:**

Класс Bird → метод fly().
Потом наследник Penguin : Bird, но пингвин не летает, и fly() ломает логику.
То есть плохая иерархия наследования

**Хорошо:**

Разделить:
```text
Bird
FlyingBird : Bird
Penguin : Bird (без fly())
```
---

## I — Interface Segregation Principle  
(Принцип разделения интерфейсов)

Лучше иметь **много маленьких интерфейсов**, чем один перегруженный.

Класс **не должен зависеть** от методов, которые **он не использует**.

**Плохо:**

Интерфейс IAnimal с методами:
```text
run()
swim()
fly()
```
**Хорошо:**

Разделить:
```text
IRunning
ISwimming
IFlying
```

Каждый класс реализует только нужные ему интерфейсы

---

## D — Dependency Inversion Principle  
(Принцип инверсии зависимостей)

Модули верхнего уровня **не должны зависеть от деталей**.  
И высокоуровневые, и низкоуровневые модули должны зависеть от **абстракций**.

Программа должна зависеть **от интерфейсов**, а не от конкретных классов.

**Плохо:**

ReportService напрямую создаёт:

```text
mailer = SMTPSender()
```

**Хорошо:**

Принимать абстракцию:

```text
def __init__(self, mail_sender: MailSenderProtocol):
    self.mail_sender = mail_sender
```

